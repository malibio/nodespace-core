-- ============================================================================
-- NodeSpace SurrealDB Schema - Hub-and-Spoke Architecture with Record Links
-- ============================================================================
--
-- This schema implements a hub-and-spoke design where:
-- 1. Hub (node table) - Universal metadata for ALL node types
-- 2. Spokes - Type-specific queryable data:
--    - Schema spoke (structural, defined here)
--    - Other spokes (e.g., task) generated from schema definitions at runtime
-- 3. Record Links - Bidirectional pointers for 1-to-1 composition (NOT RELATE)
-- 4. Graph Edges - has_child and mentions for node-to-node relationships
--
-- Key Pattern: Use Record Links for composition, RELATE for relationships
-- Schema-based spoke tables are generated by SchemaTableManager (Issue #691)
-- ============================================================================

-- ============================================================================
-- HUB TABLE (SCHEMAFULL - Universal metadata)
-- ============================================================================

-- Node table: Universal metadata for ALL node types
DEFINE TABLE IF NOT EXISTS node SCHEMAFULL;

-- Required universal fields
-- NOTE: 'id' is the Record ID (primary key) and is automatically managed by SurrealDB
-- Do NOT redefine it - let SurrealDB handle it natively as a Thing type
DEFINE FIELD IF NOT EXISTS content ON TABLE node TYPE string DEFAULT "";
DEFINE FIELD IF NOT EXISTS node_type ON TABLE node TYPE string ASSERT $value != NONE;
DEFINE FIELD IF NOT EXISTS data ON TABLE node TYPE option<record>;  -- Record Link to spoke (task, schema, or NULL)
DEFINE FIELD IF NOT EXISTS version ON TABLE node TYPE int DEFAULT 1 ASSERT $value >= 1;
DEFINE FIELD IF NOT EXISTS created_at ON TABLE node TYPE datetime DEFAULT time::now();
DEFINE FIELD IF NOT EXISTS modified_at ON TABLE node TYPE datetime DEFAULT time::now();

-- Indexes for performance
DEFINE INDEX IF NOT EXISTS idx_node_type ON TABLE node COLUMNS node_type;
DEFINE INDEX IF NOT EXISTS idx_node_modified ON TABLE node COLUMNS modified_at;

-- NO beforeSiblingId - structure lives in has_child edges!
-- NO parentId - hierarchy lives in has_child edges!

-- ============================================================================
-- SPOKE TABLES (Type-specific queryable data)
-- ============================================================================

-- ============================================================================
-- NOTE: Task spoke table is now generated dynamically from schema definitions
-- by SchemaTableManager.sync_schema_to_database() during core schema seeding.
-- See Issue #691 for details on the consolidated schema seeding approach.
-- ============================================================================

-- ============================================================================
-- NOTE: Date spoke table removed (Issue #670) - date nodes store all data
-- in the hub node table's content field, no need for separate spoke table.
-- ============================================================================

-- Schema spoke: Type definitions (STRUCTURAL - not derived from schema nodes)
DEFINE TABLE IF NOT EXISTS schema SCHEMALESS;
DEFINE FIELD IF NOT EXISTS node ON TABLE schema TYPE option<record>;  -- Reverse link to hub node

-- Core schema fields
-- NOTE: Using native array<object> storage for fields to enable querying inside schemas
-- (e.g., "Find all schemas with a core-protected field")
-- Strong typing with Rust structs handles enum serialization/deserialization correctly
DEFINE FIELD IF NOT EXISTS is_core ON TABLE schema TYPE bool DEFAULT false;
DEFINE FIELD IF NOT EXISTS version ON TABLE schema TYPE int DEFAULT 1;
DEFINE FIELD IF NOT EXISTS description ON TABLE schema TYPE string DEFAULT "";

-- Fields array: stores SchemaField objects as flexible array
-- Using FLEXIBLE to allow nested structures without strict constraints
-- Validation is handled by Rust structs during serialization/deserialization
-- Note: Changed from option<string> (stringified JSON) to option<array> to enable
-- queryability and proper enum handling (see issue #587)
DEFINE FIELD IF NOT EXISTS fields ON TABLE schema FLEXIBLE TYPE option<array> DEFAULT [];

-- Relationships array: stores SchemaRelationship objects for user-defined relationships
-- Each relationship generates an edge table at runtime (see Issue #703)
-- Structural relationships (has_child, mentions) remain hardcoded in this file
-- Note: Using FLEXIBLE to allow nested edgeFields without strict constraints
DEFINE FIELD IF NOT EXISTS relationships ON TABLE schema FLEXIBLE TYPE option<array> DEFAULT [];

-- ============================================================================
-- GRAPH RELATIONS (SCHEMAFULL - Node-to-node relationships)
-- ============================================================================

-- Has_child relation: Hierarchical relationships with fractional ordering
DEFINE TABLE IF NOT EXISTS has_child SCHEMAFULL TYPE RELATION IN node OUT node;

-- Required fields for hierarchy
DEFINE FIELD IF NOT EXISTS order ON TABLE has_child TYPE float ASSERT $value != NONE;
DEFINE FIELD IF NOT EXISTS created_at ON TABLE has_child TYPE datetime DEFAULT time::now();
DEFINE FIELD IF NOT EXISTS version ON TABLE has_child TYPE int DEFAULT 1;  -- OCC for concurrent edits

-- Index for efficient ordering queries
DEFINE INDEX IF NOT EXISTS idx_child_order ON TABLE has_child COLUMNS in, order;

-- Ensure unique parent-child relationships
DEFINE INDEX IF NOT EXISTS idx_unique_child ON TABLE has_child COLUMNS in, out UNIQUE;

-- ============================================================================

-- Mentions relation: Bidirectional references between nodes
DEFINE TABLE IF NOT EXISTS mentions SCHEMAFULL TYPE RELATION IN node OUT node;

-- Required base fields
DEFINE FIELD IF NOT EXISTS created_at ON TABLE mentions TYPE datetime DEFAULT time::now();
DEFINE FIELD IF NOT EXISTS context ON TABLE mentions TYPE string DEFAULT "";
DEFINE FIELD IF NOT EXISTS offset ON TABLE mentions TYPE int DEFAULT 0;
DEFINE FIELD IF NOT EXISTS root_id ON TABLE mentions TYPE option<string>;  -- Root node of mentioning node's tree

-- Indexes for efficient queries
DEFINE INDEX IF NOT EXISTS idx_mentions_in ON TABLE mentions COLUMNS in;
DEFINE INDEX IF NOT EXISTS idx_mentions_out ON TABLE mentions COLUMNS out;

-- Prevent duplicate mentions
DEFINE INDEX IF NOT EXISTS idx_unique_mention ON TABLE mentions COLUMNS in, out UNIQUE;

-- ============================================================================

-- Member_of relation: Collection membership (node belongs to collection)
-- This represents the "labeling" relationship where any node can be a member
-- of one or more collection nodes. Collections form a DAG (Directed Acyclic Graph).
--
-- Direction: member_of goes FROM member node TO collection node
-- Example: node:abc -> collection:engineering means "abc belongs to engineering"
--
-- Note: Collection hierarchy uses has_child edges, not member_of.
-- member_of is only for non-collection nodes joining collections.
DEFINE TABLE IF NOT EXISTS member_of SCHEMAFULL TYPE RELATION IN node OUT node;

-- Required base fields
DEFINE FIELD IF NOT EXISTS created_at ON TABLE member_of TYPE datetime DEFAULT time::now();

-- Indexes for efficient queries
-- "What collections does this node belong to?" - query by `in`
DEFINE INDEX IF NOT EXISTS idx_member_of_in ON TABLE member_of COLUMNS in;
-- "What nodes belong to this collection?" - query by `out`
DEFINE INDEX IF NOT EXISTS idx_member_of_out ON TABLE member_of COLUMNS out;

-- Prevent duplicate memberships (a node can only join a collection once)
DEFINE INDEX IF NOT EXISTS idx_unique_membership ON TABLE member_of COLUMNS in, out UNIQUE;

-- ============================================================================
-- EMBEDDINGS TABLE (Root-Aggregate Model for Semantic Search)
-- ============================================================================
--
-- NodeSpace uses a root-aggregate embedding model:
-- - Only ROOT nodes (no parent edge) of embeddable types get embedded
-- - Embeddings represent the semantic content of the entire subtree
-- - Chunking support for content > 512 tokens
-- - Backend-managed queue with debouncing (no frontend involvement)
--
-- Embeddable types: text, header, code-block, schema
-- NOT embeddable: task, date, person, ai-chat, any child node
-- ============================================================================

DEFINE TABLE IF NOT EXISTS embedding SCHEMAFULL;

-- Link to root node (consistent with spoke pattern)
-- Uses record<node> type for SurrealDB record link semantics
DEFINE FIELD IF NOT EXISTS node ON TABLE embedding TYPE record<node>;

-- Vector data
DEFINE FIELD IF NOT EXISTS vector ON TABLE embedding TYPE array<float>;
DEFINE FIELD IF NOT EXISTS dimension ON TABLE embedding TYPE int DEFAULT 384;

-- Model info (future multi-model support)
DEFINE FIELD IF NOT EXISTS model_name ON TABLE embedding TYPE string DEFAULT 'bge-small-en-v1.5';

-- Chunking support (for content > 512 tokens)
DEFINE FIELD IF NOT EXISTS chunk_index ON TABLE embedding TYPE int DEFAULT 0;
DEFINE FIELD IF NOT EXISTS chunk_start ON TABLE embedding TYPE int DEFAULT 0;
DEFINE FIELD IF NOT EXISTS chunk_end ON TABLE embedding TYPE option<int>;
DEFINE FIELD IF NOT EXISTS total_chunks ON TABLE embedding TYPE int DEFAULT 1;

-- Content tracking (for change detection)
DEFINE FIELD IF NOT EXISTS content_hash ON TABLE embedding TYPE option<string>;
DEFINE FIELD IF NOT EXISTS token_count ON TABLE embedding TYPE option<int>;

-- Staleness tracking (for re-embedding queue)
DEFINE FIELD IF NOT EXISTS stale ON TABLE embedding TYPE bool DEFAULT true;

-- Error tracking
DEFINE FIELD IF NOT EXISTS error_count ON TABLE embedding TYPE int DEFAULT 0;
DEFINE FIELD IF NOT EXISTS last_error ON TABLE embedding TYPE option<string>;

-- Timestamps
DEFINE FIELD IF NOT EXISTS created_at ON TABLE embedding TYPE datetime DEFAULT time::now();
DEFINE FIELD IF NOT EXISTS modified_at ON TABLE embedding TYPE datetime DEFAULT time::now();

-- Indexes for efficient lookups
DEFINE INDEX IF NOT EXISTS idx_embedding_node ON TABLE embedding COLUMNS node;
DEFINE INDEX IF NOT EXISTS idx_embedding_stale ON TABLE embedding COLUMNS stale;
-- Unique constraint: one embedding per (node, model, chunk_index) combination
DEFINE INDEX IF NOT EXISTS idx_embedding_unique ON TABLE embedding COLUMNS node, model_name, chunk_index UNIQUE;

-- ============================================================================
-- Schema Version Tracking
-- ============================================================================

-- Track schema version for migrations
DEFINE FIELD IF NOT EXISTS _schema_version ON TABLE node TYPE int DEFAULT 1;
