-- ============================================================================
-- NodeSpace SurrealDB Schema - Hub-and-Spoke Architecture with Record Links
-- ============================================================================
--
-- This schema implements a hub-and-spoke design where:
-- 1. Hub (node table) - Universal metadata for ALL node types
-- 2. Spokes - Type-specific queryable data:
--    - Schema spoke (structural, defined here)
--    - Other spokes (e.g., task) generated from schema definitions at runtime
-- 3. Record Links - Bidirectional pointers for 1-to-1 composition (NOT RELATE)
-- 4. Graph Edges - has_child and mentions for node-to-node relationships
--
-- Key Pattern: Use Record Links for composition, RELATE for relationships
-- Schema-based spoke tables are generated by SchemaTableManager (Issue #691)
-- ============================================================================

-- ============================================================================
-- HUB TABLE (SCHEMAFULL - Universal metadata)
-- ============================================================================

-- Node table: Universal metadata for ALL node types
DEFINE TABLE IF NOT EXISTS node SCHEMAFULL;

-- Required universal fields
-- NOTE: 'id' is the Record ID (primary key) and is automatically managed by SurrealDB
-- Do NOT redefine it - let SurrealDB handle it natively as a Thing type
DEFINE FIELD IF NOT EXISTS content ON TABLE node TYPE string DEFAULT "";
DEFINE FIELD IF NOT EXISTS node_type ON TABLE node TYPE string ASSERT $value != NONE;
DEFINE FIELD IF NOT EXISTS data ON TABLE node TYPE option<record>;  -- Record Link to spoke (task, schema, or NULL)
DEFINE FIELD IF NOT EXISTS version ON TABLE node TYPE int DEFAULT 1 ASSERT $value >= 1;
DEFINE FIELD IF NOT EXISTS created_at ON TABLE node TYPE datetime DEFAULT time::now();
DEFINE FIELD IF NOT EXISTS modified_at ON TABLE node TYPE datetime DEFAULT time::now();

-- Indexes for performance
DEFINE INDEX IF NOT EXISTS idx_node_type ON TABLE node COLUMNS node_type;
DEFINE INDEX IF NOT EXISTS idx_node_modified ON TABLE node COLUMNS modified_at;

-- NO beforeSiblingId - structure lives in has_child edges!
-- NO parentId - hierarchy lives in has_child edges!

-- ============================================================================
-- SPOKE TABLES (Type-specific queryable data)
-- ============================================================================

-- ============================================================================
-- NOTE: Task spoke table is now generated dynamically from schema definitions
-- by SchemaTableManager.sync_schema_to_database() during core schema seeding.
-- See Issue #691 for details on the consolidated schema seeding approach.
-- ============================================================================

-- ============================================================================
-- NOTE: Date spoke table removed (Issue #670) - date nodes store all data
-- in the hub node table's content field, no need for separate spoke table.
-- ============================================================================

-- Schema spoke: Type definitions (STRUCTURAL - not derived from schema nodes)
DEFINE TABLE IF NOT EXISTS schema SCHEMALESS;
DEFINE FIELD IF NOT EXISTS node ON TABLE schema TYPE option<record>;  -- Reverse link to hub node

-- Core schema fields
-- NOTE: Using native array<object> storage for fields to enable querying inside schemas
-- (e.g., "Find all schemas with a core-protected field")
-- Strong typing with Rust structs handles enum serialization/deserialization correctly
DEFINE FIELD IF NOT EXISTS is_core ON TABLE schema TYPE bool DEFAULT false;
DEFINE FIELD IF NOT EXISTS version ON TABLE schema TYPE int DEFAULT 1;
DEFINE FIELD IF NOT EXISTS description ON TABLE schema TYPE string DEFAULT "";

-- Fields array: stores SchemaField objects as flexible array
-- Using FLEXIBLE to allow nested structures without strict constraints
-- Validation is handled by Rust structs during serialization/deserialization
-- Note: Changed from option<string> (stringified JSON) to option<array> to enable
-- queryability and proper enum handling (see issue #587)
DEFINE FIELD IF NOT EXISTS fields ON TABLE schema FLEXIBLE TYPE option<array> DEFAULT [];

-- ============================================================================
-- GRAPH RELATIONS (SCHEMAFULL - Node-to-node relationships)
-- ============================================================================

-- Has_child relation: Hierarchical relationships with fractional ordering
DEFINE TABLE IF NOT EXISTS has_child SCHEMAFULL TYPE RELATION IN node OUT node;

-- Required fields for hierarchy
DEFINE FIELD IF NOT EXISTS order ON TABLE has_child TYPE float ASSERT $value != NONE;
DEFINE FIELD IF NOT EXISTS created_at ON TABLE has_child TYPE datetime DEFAULT time::now();
DEFINE FIELD IF NOT EXISTS version ON TABLE has_child TYPE int DEFAULT 1;  -- OCC for concurrent edits

-- Index for efficient ordering queries
DEFINE INDEX IF NOT EXISTS idx_child_order ON TABLE has_child COLUMNS in, order;

-- Ensure unique parent-child relationships
DEFINE INDEX IF NOT EXISTS idx_unique_child ON TABLE has_child COLUMNS in, out UNIQUE;

-- ============================================================================

-- Mentions relation: Bidirectional references between nodes
DEFINE TABLE IF NOT EXISTS mentions SCHEMAFULL TYPE RELATION IN node OUT node;

-- Required base fields
DEFINE FIELD IF NOT EXISTS created_at ON TABLE mentions TYPE datetime DEFAULT time::now();
DEFINE FIELD IF NOT EXISTS context ON TABLE mentions TYPE string DEFAULT "";
DEFINE FIELD IF NOT EXISTS offset ON TABLE mentions TYPE int DEFAULT 0;
DEFINE FIELD IF NOT EXISTS root_id ON TABLE mentions TYPE option<string>;  -- Root node of mentioning node's tree

-- Indexes for efficient queries
DEFINE INDEX IF NOT EXISTS idx_mentions_in ON TABLE mentions COLUMNS in;
DEFINE INDEX IF NOT EXISTS idx_mentions_out ON TABLE mentions COLUMNS out;

-- Prevent duplicate mentions
DEFINE INDEX IF NOT EXISTS idx_unique_mention ON TABLE mentions COLUMNS in, out UNIQUE;

-- ============================================================================
-- EMBEDDINGS TABLE (Vector storage for semantic search)
-- ============================================================================

-- Embeddings table: Stores vector embeddings for semantic search
-- Separate from node table for flexibility in multi-model support and efficient vector operations
DEFINE TABLE IF NOT EXISTS embedding SCHEMAFULL;

-- Required fields
DEFINE FIELD IF NOT EXISTS node_id ON TABLE embedding TYPE record<node> ASSERT $value != NONE;
DEFINE FIELD IF NOT EXISTS model_name ON TABLE embedding TYPE string DEFAULT 'bge-small-en-v1.5';
DEFINE FIELD IF NOT EXISTS vector ON TABLE embedding TYPE array<float> ASSERT $value != NONE;
DEFINE FIELD IF NOT EXISTS dimension ON TABLE embedding TYPE int ASSERT $value > 0;
DEFINE FIELD IF NOT EXISTS created_at ON TABLE embedding TYPE datetime DEFAULT time::now();
DEFINE FIELD IF NOT EXISTS modified_at ON TABLE embedding TYPE datetime DEFAULT time::now();

-- Indexes for efficient lookups
DEFINE INDEX IF NOT EXISTS idx_embedding_node ON TABLE embedding COLUMNS node_id;
DEFINE INDEX IF NOT EXISTS idx_embedding_model ON TABLE embedding COLUMNS model_name;
-- Unique constraint: one embedding per node per model
DEFINE INDEX IF NOT EXISTS idx_embedding_unique ON TABLE embedding COLUMNS node_id, model_name UNIQUE;

-- ============================================================================
-- Schema Version Tracking
-- ============================================================================

-- Track schema version for migrations
DEFINE FIELD IF NOT EXISTS _schema_version ON TABLE node TYPE int DEFAULT 1;
